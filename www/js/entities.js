// Generated by CoffeeScript 1.6.2
/*
#  Baseclass for Sprites that have pre-rendered rotations.
#  Essentially we have certain number of raytraced rotation
#  images, then we use normal rotation on the canvas for finer
#  control.
#
#  Sprites are simple plane meshes.
#
*/


(function() {
  var AnimatedSprite, Lander, MissileBase, Rocket, RotationalSprite,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  RotationalSprite = (function() {
    function RotationalSprite(config) {
      this.game = config.game;
      this.game.entities.push(this);
      this.atlasUvs = config.atlasUvs;
      this.spriteW = config.spriteW;
      this.spriteH = config.spriteH;
      this.angleOffset = config.angleOffset;
      this.createBody(config);
      this.geometry = new THREE.PlaneGeometry(config.sideLength / 2, config.sideLength / 2, 1, 1);
      this.mesh = new THREE.Mesh(this.geometry, global.landerMaterial);
      this.game.scene.add(this.mesh);
      this.steering = 0;
    }

    RotationalSprite.prototype.createBody = function() {
      return void 0;
    };

    RotationalSprite.prototype.setPosition = function(x, y) {
      return this.body.SetPosition(new b2Vec2(x, y));
    };

    RotationalSprite.prototype.update = function(dt) {
      var a, frame, v, x, y;

      x = this.body.GetPosition().x / b2Scale;
      y = this.body.GetPosition().y / b2Scale;
      this.mesh.position.x = x;
      this.mesh.position.y = y;
      this.mesh.position.z = -1;
      a = this.body.GetAngle() + Math.PI / 2;
      if (this.atlasUvs.length > 0) {
        a = signedMod(a, Math.PI * 2);
        frame = Math.floor(signedMod(a / Math.PI / 2 * 99 + this.angleOffset, 100));
        v = this.atlasUvs[frame];
        this.geometry.faceVertexUvs = [[[vector2(v.x, 1 - v.y), vector2(v.x + this.spriteW, 1 - v.y), vector2(v.x + this.spriteW, 1 - v.y - this.spriteH), vector2(v.x, 1 - v.y - this.spriteH)]]];
        this.geometry.uvsNeedUpdate = true;
        return this.mesh.rotation.z = a - ((frame - this.angleOffset) / 99.0 * Math.PI * 2);
      }
    };

    return RotationalSprite;

  })();

  Lander = (function(_super) {
    __extends(Lander, _super);

    function Lander(game) {
      Lander.__super__.constructor.call(this, {
        game: game,
        atlasUvs: landerFrameUvs,
        width: 9,
        height: 2,
        mass: 1000000,
        spriteW: 64 / atlas_w,
        spriteH: 64 / atlas_h,
        x: 0,
        y: 0,
        angleOffset: 0,
        sideLength: 64,
        friction: 0.8
      });
      this.fuel = 30;
      this.damage = 0;
      this.exhaustGeometry = new THREE.PlaneGeometry(32, 32, 1, 1);
      this.exhaustMesh = new THREE.Mesh(this.exhaustGeometry, global.exhaustMaterial);
      this.exhaustStrength = 0;
      this.exhaustCycle = 0;
      this.game.scene.add(this.exhaustMesh);
    }

    Lander.prototype.createBody = function(config) {
      var body, bodyDef, fixtureDef;

      bodyDef = new b2BodyDef;
      this.bodyDef = bodyDef;
      bodyDef.type = b2Body.b2_dynamicBody;
      bodyDef.position.x = config.x * b2Scale;
      bodyDef.position.y = config.y * b2Scale;
      bodyDef.angle = 0.01;
      body = this.game.world.CreateBody(bodyDef);
      body.test = "test";
      this.body = body;
      body.w = config.width * b2Scale;
      body.h = config.height * b2Scale;
      fixtureDef = new b2FixtureDef;
      fixtureDef.restitution = 0.1;
      fixtureDef.density = config.mass / body.w / body.h;
      fixtureDef.friction = config.friction;
      fixtureDef.shape = new b2PolygonShape.AsOrientedBox(body.w, body.h, new b2Vec2(0, 4 * b2Scale), 0);
      fixtureDef.userData = "landingGear";
      body.CreateFixture(fixtureDef);
      fixtureDef = new b2FixtureDef;
      fixtureDef.restitution = 0.1;
      fixtureDef.density = config.mass / body.w / body.h;
      fixtureDef.friction = 0.4;
      fixtureDef.shape = new b2CircleShape(4 * b2Scale);
      fixtureDef.shape.SetLocalPosition(new b2Vec2(0, -5 * b2Scale));
      fixtureDef.userData = "landerSphere";
      return body.CreateFixture(fixtureDef);
    };

    Lander.prototype.update = function(dt) {
      var a, f, frame, h, p1, thrust, v, vel, w, x, y;

      x = this.body.GetPosition().x / b2Scale;
      y = this.body.GetPosition().y / b2Scale;
      a = this.body.GetAngle();
      vel = this.game.lander.body.GetLinearVelocity();
      this.velD = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
      this.vel = vel;
      this.body.m_torque = 2800000 * dt * this.steering;
      this.fuel -= (this.thrust ? 1 : 0) * dt;
      this.fuel = Math.max(0, this.fuel);
      if (this.fuel === 0) {
        if (this.outOfFuel == null) {
          this.outOfFuel = true;
          this.game.terminal.display("Out of Fuel. Press 'r' to retry ...");
        }
        this.thrust = 0;
      }
      this.exhaustStrength += (this.thrust ? 1 : -1) * 5 * dt;
      this.exhaustStrength = Math.min(Math.max(this.exhaustStrength, 0), 1);
      global.exhaustMaterial.opacity = this.exhaustStrength;
      if (global.engine != null) {
        global.engine.setVolume(0.2 * this.exhaustStrength);
      }
      thrust = 120000000 * dt * this.thrust;
      f = new b2Vec2(thrust * Math.sin(a), -thrust * Math.cos(a));
      p1 = new b2Vec2(x * b2Scale, y * b2Scale);
      this.body.ApplyForce(f, p1);
      Lander.__super__.update.call(this, dt);
      this.exhaustCycle += dt * 15;
      this.exhaustCycle %= 25;
      frame = Math.floor(this.exhaustCycle);
      v = exhaustFrameUvs[frame];
      w = 64 / atlas_w;
      h = 64 / atlas_h;
      this.exhaustGeometry.faceVertexUvs = [[[vector2(v.x, 1 - v.y), vector2(v.x + w, 1 - v.y), vector2(v.x + w, 1 - v.y - h), vector2(v.x, 1 - v.y - h)]]];
      this.exhaustGeometry.uvsNeedUpdate = true;
      this.exhaustMesh.position.x = x;
      this.exhaustMesh.position.y = y;
      this.exhaustMesh.position.z = 10;
      return this.exhaustMesh.rotation.z = a + Math.PI / 2;
    };

    return Lander;

  })(RotationalSprite);

  Rocket = (function(_super) {
    __extends(Rocket, _super);

    function Rocket(config) {
      this.update = __bind(this.update, this);      config.game = config.game;
      config.atlasUvs = rocketFrameUvs;
      config.width = 2.6;
      config.height = 15;
      config.sideLength = 100;
      config.spriteW = 100 / atlas_w;
      config.spriteH = 100 / atlas_h;
      config.friction = 0.1;
      config.mass = 10000000;
      config.angleOffset = 0;
      Rocket.__super__.constructor.call(this, config);
      this.mesh.position.z = -1;
    }

    Rocket.prototype.createBody = function(config) {
      var body, bodyDef, fixtureDef, shape;

      bodyDef = new b2BodyDef;
      this.bodyDef = bodyDef;
      bodyDef.type = b2Body.b2_dynamicBody;
      bodyDef.position.x = config.x * b2Scale;
      bodyDef.position.y = config.y * b2Scale;
      bodyDef.angle = 0;
      body = this.game.world.CreateBody(bodyDef);
      body.test = "test";
      this.body = body;
      body.w = config.width * b2Scale;
      body.h = config.height * b2Scale;
      fixtureDef = new b2FixtureDef;
      fixtureDef.restitution = 0.1;
      fixtureDef.density = config.mass / body.w / body.h;
      fixtureDef.friction = config.friction;
      shape = new b2PolygonShape.AsBox(body.w, body.h);
      fixtureDef.shape = shape;
      return body.CreateFixture(fixtureDef);
    };

    Rocket.prototype.update = function(dt) {
      return Rocket.__super__.update.call(this, dt);
    };

    return Rocket;

  })(RotationalSprite);

  AnimatedSprite = (function() {
    function AnimatedSprite(config) {
      this.game = config.game;
      this.game.entities.push(this);
      this.atlasUvs = config.atlasUvs;
      this.spriteW = config.spriteW;
      this.spriteH = config.spriteH;
      this.screenWidth = config.screenWidth;
      this.screenHeight = config.screenHeight;
      this.geometry = new THREE.PlaneGeometry(this.screenWidth / 2, this.screenHeight / 2, 1, 1);
      this.mesh = new THREE.Mesh(this.geometry, global.landerMaterial);
      this.game.scene.add(this.mesh);
      this.x = config.x;
      this.y = config.y;
      this.z = config.z;
      this.frame = 0;
      this.update(0.0001);
    }

    AnimatedSprite.prototype.update = function(dt) {
      var h, v, w;

      this.mesh.position.x = this.x;
      this.mesh.position.y = this.y;
      this.mesh.position.z = this.z;
      this.mesh.rotation.z = Math.PI / 2;
      v = this.atlasUvs[Math.floor(this.frame)];
      w = this.spriteW / atlas_w;
      h = this.spriteH / atlas_h;
      this.geometry.faceVertexUvs = [[[vector2(v.x, 1 - v.y), vector2(v.x + w, 1 - v.y), vector2(v.x + w, 1 - v.y - h), vector2(v.x, 1 - v.y - h)]]];
      return this.geometry.uvsNeedUpdate = true;
    };

    return AnimatedSprite;

  })();

  MissileBase = (function(_super) {
    __extends(MissileBase, _super);

    function MissileBase(config) {
      this.update = __bind(this.update, this);      this.exploded = false;
      MissileBase.__super__.constructor.call(this, {
        game: config.game,
        x: config.x,
        y: config.y - 10,
        z: -2,
        spriteW: 80,
        spriteH: 80,
        screenWidth: 80,
        screenHeight: 80,
        atlasUvs: baseFrameUvs
      });
      this.game.bases.push(this);
    }

    MissileBase.prototype.update = function(dt) {
      var print,
        _this = this;

      if (this.exploded) {
        this.frame += dt * 15;
        this.frame = Math.min(this.frame, 63);
      }
      MissileBase.__super__.update.call(this, dt);
      if (this.game.lander.velD < 0.01) {
        if (Math.abs(this.x - this.game.lander.mesh.position.x) < 7) {
          if (Math.abs(this.y - this.game.lander.mesh.position.y - 5) < 20) {
            if (Math.abs(signedMod(this.game.lander.body.GetAngle(), Math.PI * 2)) < Math.PI / 360 * 10) {
              if (!this.exploded) {
                this.game.basesDestroyed += 1;
                if (this.game.basesDestroyed === this.game.basesTotal) {
                  this.game.levelUp();
                }
                this.exploded = true;
                this.game.lander.fuel = Math.min(this.game.lander.fuel + 15, 45);
                print = function(s) {
                  return _this.game.terminal.display(s);
                };
                if (this.game.levelNumber === 1) {
                  switch (this.game.basesDestroyed) {
                    case 1:
                      return print("The eagle has landed...");
                    case 2:
                      print("One small step for man...");
                      return print("One huge BOOM for mankind...");
                  }
                }
              }
            }
          }
        }
      }
    };

    return MissileBase;

  })(AnimatedSprite);

}).call(this);
