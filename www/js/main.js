// Generated by CoffeeScript 1.4.0
(function() {
  var Game, Lander, Sprite, atlas, atlas_h, atlas_w, b2Scale, countDown, face3, face4, game, jsonLoader, landerFrameUvs, landerGeometry, pushFaces, pushVertices, spriteH, spriteW, terrainSurface, vector2, vertex, zeroFill,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.global = {
    width: 1020,
    height: 600
  };

  b2Scale = 0.01;

  global.renderer = new THREE.CanvasRenderer({
    canvas: $("canvas")[0]
  });

  global.scene = new THREE.Scene();

  global.camera = new THREE.OrthographicCamera(-window.global.width / 4, window.global.width / 4, -window.global.height / 4, window.global.height / 4, 1, 3000);

  global.camera.position.z = 1000;

  global.scene.add(global.camera);

  global.renderer.setSize(global.width, global.height);

  vertex = function(x, y, z) {
    if (z === void 0) {
      z = 0;
    }
    return new THREE.Vector3(x, y, z);
  };

  pushVertices = function(geometry, vertices) {
    var v, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = vertices.length; _i < _len; _i++) {
      v = vertices[_i];
      _results.push(geometry.vertices.push(v));
    }
    return _results;
  };

  face3 = function(a, b, c) {
    return new THREE.Face3(a, b, c);
  };

  face4 = function(a, b, c, d) {
    return new THREE.Face4(a, b, c, d);
  };

  pushFaces = function(geometry, faces) {
    var f, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = faces.length; _i < _len; _i++) {
      f = faces[_i];
      _results.push(geometry.faces.push(f));
    }
    return _results;
  };

  landerGeometry = new THREE.Geometry();

  pushVertices(landerGeometry, [vertex(-15, -15), vertex(15, -15), vertex(15, 15), vertex(-15, 15)]);

  pushFaces(landerGeometry, [face4(3, 2, 1, 0)]);

  atlas = THREE.ImageUtils.loadTexture("img/textures.png");

  atlas_w = 1022;

  atlas_h = 1520;

  landerGeometry = new THREE.PlaneGeometry(30, 30, 1, 1);

  vector2 = function(x, y) {
    return new THREE.Vector2(x, y);
  };

  spriteW = 64 / atlas_w;

  spriteH = 64 / atlas_h;

  jsonLoader = new THREE.JSONLoader();

  global.landerMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    side: THREE.DoubleSide,
    shading: THREE.FlatShading,
    map: atlas,
    overdraw: true
  });

  terrainSurface = THREE.ImageUtils.loadTexture("img/lunarsurface.png");

  terrainSurface.wrapS = THREE.RepeatWrapping;

  terrainSurface.wrapT = THREE.RepeatWrapping;

  global.levelMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    side: THREE.DoubleSide,
    shading: THREE.FlatShading,
    overdraw: true,
    map: terrainSurface
  });

  global.resourceCount = 0;

  countDown = function(func) {
    global.resourceCount += 1;
    return function() {
      func.apply(null, arguments);
      return global.resourceCount -= 1;
    };
  };

  zeroFill = function(i, n) {
    var a, j, _i, _ref;
    a = [];
    for (j = _i = 0, _ref = Math.floor(Math.log(i) / Math.log(10)) - n + 2; 0 <= _ref ? _i <= _ref : _i >= _ref; j = 0 <= _ref ? ++_i : --_i) {
      a.push("0");
    }
    return a.join("") + i;
  };

  landerFrameUvs = [];

  $.getJSON('js/textures.json', {}, countDown(function(data) {
    var frame, i, s, _i, _results;
    _results = [];
    for (i = _i = 1; _i <= 100; i = ++_i) {
      s = 'lander' + zeroFill(i, 4) + '.png';
      frame = data.frames[s].frame;
      _results.push(landerFrameUvs.push(vector2(frame.x / atlas_w, frame.y / atlas_h)));
    }
    return _results;
  }));

  Game = (function() {

    function Game() {
      this.mainLoop = __bind(this.mainLoop, this);

      this.keyUp = __bind(this.keyUp, this);

      this.keyDown = __bind(this.keyDown, this);

      var body, gravity, preventDefault,
        _this = this;
      gravity = new b2Vec2(0, 10 * b2Scale);
      this.world = new b2World(gravity, true);
      this.lander = new Lander(this);
      body = $("body");
      preventDefault = function(func) {
        return function(event) {
          var r;
          r = func(event);
          event.preventDefault();
          return r;
        };
      };
      body.keydown(this.keyDown);
      body.keyup(this.keyUp);
      this.pressedKeys = {};
      new THREE.JSONLoader().load("js/level1.js", function(model) {
        var a, b, count, countEdge, edge, edges, face, v1, v2, verts, _i, _len, _ref, _ref1, _results;
        _this.level = new THREE.Mesh(model, global.levelMaterial);
        global.scene.add(_this.level);
        _this.level.position.x = 0;
        _this.level.position.y = 0;
        _this.level.position.z = -1;
        _this.level.scale.y = -1;
        _this.level.scale.x = 1;
        verts = model.vertices;
        edges = {};
        countEdge = function(a, b) {
          var s, v;
          v = [a, b];
          v.sort();
          a = v[0], b = v[1];
          s = "" + a + "-" + b;
          return edges[s] = edges[s] != null ? edges[s] + 1 : 1;
        };
        _ref = model.faces;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          face = _ref[_i];
          countEdge(face.a, face.b);
          countEdge(face.b, face.c);
          countEdge(face.c, face.a);
        }
        _results = [];
        for (edge in edges) {
          count = edges[edge];
          if (count === 1) {
            _ref1 = edge.split("-"), a = _ref1[0], b = _ref1[1];
            v1 = new b2Vec2(verts[a].x * b2Scale, -verts[a].y * b2Scale);
            v2 = new b2Vec2(verts[b].x * b2Scale, -verts[b].y * b2Scale);
            _results.push(_this.makeEdge(v1, v2));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    }

    Game.prototype.keyDown = function(event) {
      return this.pressedKeys[event.keyCode] = true;
    };

    Game.prototype.keyUp = function(event) {
      return this.pressedKeys[event.keyCode] = false;
    };

    Game.prototype.mainLoop = function() {
      var dt, newFrame;
      newFrame = new Date().getTime();
      dt = (newFrame - this.lastFrame) / 1000;
      if (dt > 2) {
        dt = 0.01;
      }
      this.lastFrame = newFrame;
      requestAnimationFrame(this.mainLoop);
      this.lander.steering = 0;
      if (this.pressedKeys[37]) {
        this.lander.steering = -1;
      }
      if (this.pressedKeys[39]) {
        this.lander.steering = 1;
      }
      this.lander.thrust = this.pressedKeys[38] ? 1 : 0;
      this.world.Step(dt, 5, 5);
      this.world.ClearForces();
      this.lander.update(dt);
      global.camera.position.x = this.lander.mesh.position.x;
      global.camera.position.y = this.lander.mesh.position.y;
      return global.renderer.render(global.scene, global.camera);
    };

    Game.prototype.launch = function() {
      this.lastFrame = new Date().getTime();
      return this.mainLoop();
    };

    Game.prototype.makeEdge = function(v1, v2) {
      var body, bodyDef, fixtureDef, shape;
      bodyDef = new b2BodyDef();
      bodyDef.type = b2Body.b2_staticBody;
      bodyDef.position.x = 0;
      bodyDef.position.y = 0;
      bodyDef.angle = 0;
      body = this.world.CreateBody(bodyDef);
      fixtureDef = new b2FixtureDef();
      fixtureDef.restitution = 0.0;
      fixtureDef.density = 2.0;
      fixtureDef.friction = 0.9;
      shape = new b2PolygonShape.AsEdge(v1, v2);
      fixtureDef.shape = shape;
      return body.CreateFixture(fixtureDef);
    };

    return Game;

  })();

  Sprite = (function() {

    function Sprite(config) {
      var body, bodyDef, fixtureDef, shape;
      this.game = config.game;
      bodyDef = new b2BodyDef;
      this.bodyDef = bodyDef;
      bodyDef.type = b2Body.b2_dynamicBody;
      bodyDef.position.x = 0;
      bodyDef.position.y = -100 * b2Scale;
      bodyDef.angle = 0;
      body = this.game.world.CreateBody(bodyDef);
      body.test = "test";
      this.body = body;
      body.w = config.width * b2Scale;
      body.h = config.height * b2Scale;
      fixtureDef = new b2FixtureDef;
      fixtureDef.restitution = 0.1;
      fixtureDef.density = 1000000 / body.w / body.h;
      fixtureDef.friction = 0.7;
      shape = new b2PolygonShape.AsBox(body.w, body.h);
      fixtureDef.shape = shape;
      body.CreateFixture(fixtureDef);
      this.mesh = new THREE.Mesh(landerGeometry, global.landerMaterial);
      global.scene.add(this.mesh);
      this.steering = 0;
    }

    Sprite.prototype.update = function(dt) {
      var a, f, frame, p1, thrust, v, x, y;
      x = this.body.GetPosition().x / b2Scale;
      y = this.body.GetPosition().y / b2Scale;
      this.mesh.position.x = x;
      this.mesh.position.y = y;
      a = this.body.GetAngle();
      this.body.m_torque = 2000000 * dt * this.steering;
      thrust = 200000000 * dt * this.thrust;
      f = new b2Vec2(thrust * Math.sin(a), -thrust * Math.cos(a));
      p1 = new b2Vec2(x * b2Scale, y * b2Scale);
      this.body.ApplyForce(f, p1);
      if (landerFrameUvs.length > 0) {
        if (a < 0) {
          a = Math.PI * 2 + (a % (Math.PI * 2));
        }
        frame = Math.floor(a / Math.PI / 2 * 100 + 25) % 100;
        v = landerFrameUvs[frame];
        landerGeometry.faceVertexUvs = [[[vector2(v.x, 1 - v.y), vector2(v.x + spriteW, 1 - v.y), vector2(v.x + spriteW, 1 - v.y - spriteH), vector2(v.x, 1 - v.y - spriteH)]]];
        landerGeometry.uvsNeedUpdate = true;
        return this.mesh.rotation.z = a - ((frame - 25) / 100.0 * Math.PI * 2);
      }
    };

    return Sprite;

  })();

  Lander = (function(_super) {

    __extends(Lander, _super);

    function Lander(game) {
      Lander.__super__.constructor.call(this, {
        game: game,
        width: 11,
        height: 6
      });
    }

    return Lander;

  })(Sprite);

  game = new Game();

  game.launch();

}).call(this);
